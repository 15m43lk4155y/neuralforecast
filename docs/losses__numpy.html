---

title: NumPy Evaluation


keywords: fastai
sidebar: home_sidebar

summary: "The most important evaluation signal is the forecast error, which is the difference between the observed value $y_{\\tau}$ and the prediction $\\hat{y}_{\\tau}$, at time $\\tau$: $$e_{\\tau} = y_{\\tau}-\\hat{y}_{\\tau} \\qquad \\qquad \\tau \\in \\{t+1,\\dots,t+H \\}.$$The forecast accuracy summarizes the forecast errors in different metrics: <br><br> 1. Scale-dependent errors - These metrics are on the same scale as the data. <ul><li>mae</li><li>mse</li><li>rmse</li></ul>   <br> 2. Percentage errors - These metrics are unit-free, suitable for comparisons across series. <ul><li>mape</li><li>smape</li></ul> <br> 3. Scale-independent errors - These metrics measure the relative improvements versus baselines, the available metric is <ul><li>mase</li><li>rmae</li></ul>   <br>4. Probabilistic errors - These measure absolute deviation non-symmetrically, that produce under/over estimation. <ul><li>quantile_loss</li><li>mqloss</li></ul>"
description: "The most important evaluation signal is the forecast error, which is the difference between the observed value $y_{\\tau}$ and the prediction $\\hat{y}_{\\tau}$, at time $\\tau$: $$e_{\\tau} = y_{\\tau}-\\hat{y}_{\\tau} \\qquad \\qquad \\tau \\in \\{t+1,\\dots,t+H \\}.$$The forecast accuracy summarizes the forecast errors in different metrics: <br><br> 1. Scale-dependent errors - These metrics are on the same scale as the data. <ul><li>mae</li><li>mse</li><li>rmse</li></ul>   <br> 2. Percentage errors - These metrics are unit-free, suitable for comparisons across series. <ul><li>mape</li><li>smape</li></ul> <br> 3. Scale-independent errors - These metrics measure the relative improvements versus baselines, the available metric is <ul><li>mase</li><li>rmae</li></ul>   <br>4. Probabilistic errors - These measure absolute deviation non-symmetrically, that produce under/over estimation. <ul><li>quantile_loss</li><li>mqloss</li></ul>"
nb_path: "nbs/losses__numpy.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/losses__numpy.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="1.-Scale-dependent-Errors-"><span style="color:DarkOrange">1. Scale-dependent Errors </span><a class="anchor-link" href="#1.-Scale-dependent-Errors-"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Mean-Absolute-Error">Mean Absolute Error<a class="anchor-link" href="#Mean-Absolute-Error"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="mae" class="doc_header"><code>mae</code><a href="https://github.com/Nixtla/neuralforecast/tree/main/neuralforecast/losses/numpy.py#L27" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>mae</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>y_hat</code></strong>:<code>ndarray</code>, <strong><code>weights</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>, <strong><code>axis</code></strong>:<code>Optional</code>[<code>int</code>]=<em><code>None</code></em>)</p>
</blockquote>
<p>Calculates Mean Absolute Error (MAE) between
y and y_hat. MAE measures the relative prediction
accuracy of a forecasting method by calculating the
deviation of the prediction and the true
value at a given time and averages these devations
over the length of the series.</p>
$$ \mathrm{MAE}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}_{\tau}) =
    \frac{1}{H} \sum^{t+H}_{\tau=t+1}
    |y_{\tau} - \hat{y}_{\tau}| $$
<pre><code>Parameters
----------
y: numpy array.
    Observed values.
y_hat: numpy array
    Predicted values.
weights: numpy array, optional.
    Weights for weighted average.
axis: None or int, optional.
    Axis or axes along which to average a.
    The default, axis=None, will average over all of the elements of
    the input array. If axis is negative it counts from last to first.

Returns
-------
mae: numpy array or double.
    Return the MAE along the specified axis.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Mean-Squared-Error">Mean Squared Error<a class="anchor-link" href="#Mean-Squared-Error"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="mse" class="doc_header"><code>mse</code><a href="https://github.com/Nixtla/neuralforecast/tree/main/neuralforecast/losses/numpy.py#L74" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>mse</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>y_hat</code></strong>:<code>ndarray</code>, <strong><code>weights</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>, <strong><code>axis</code></strong>:<code>Optional</code>[<code>int</code>]=<em><code>None</code></em>)</p>
</blockquote>
<p>Calculates Mean Squared Error (MSE) between
y and y_hat. MSE measures the relative prediction
accuracy of a forecasting method by calculating the
squared deviation of the prediction and the true
value at a given time, and averages these devations
over the length of the series.</p>
$$ \mathrm{MSE}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}_{\tau}) =
    \frac{1}{H} \sum^{t+H}_{\tau=t+1} (y_{\tau} - \hat{y}_{\tau})^{2} $$
<pre><code>Parameters
----------
y: numpy array.
    Actual test values.
y_hat: numpy array.
    Predicted values.
weights: numpy array, optional.
    Weights for weighted average.
axis: None or int, optional.
    Axis or axes along which to average a.
    The default, axis=None, will average over all of the
    elements of the input array. If axis is negative it counts
    from the last to the first axis.

Returns
-------
mse: numpy array or double.
    Return the MSE along the specified axis.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Root-Mean-Squared-Error">Root Mean Squared Error<a class="anchor-link" href="#Root-Mean-Squared-Error"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="rmse" class="doc_header"><code>rmse</code><a href="https://github.com/Nixtla/neuralforecast/tree/main/neuralforecast/losses/numpy.py#L121" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>rmse</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>y_hat</code></strong>:<code>ndarray</code>, <strong><code>weights</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>, <strong><code>axis</code></strong>:<code>Optional</code>[<code>int</code>]=<em><code>None</code></em>)</p>
</blockquote>
<p>Calculates Root Mean Squared Error (RMSE) between
y and y_hat. RMSE measures the relative prediction
accuracy of a forecasting method by calculating the squared deviation
of the prediction and the observed value at a given time and
averages these devations over the length of the series.
Finally the RMSE will be in the same scale
as the original time series so its comparison with other
series is possible only if they share a common scale.
RMSE has a direct connection to the L2 norm.</p>
$$ \mathrm{RMSE}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}_{\tau}) =
    \sqrt{\frac{1}{H} \sum^{t+H}_{\tau=t+1} (y_{\tau} - \hat{y}_{\tau})^{2}} $$
<pre><code>Parameters
----------
y: numpy array.
    Observed values.
y_hat: numpy array.
    Predicted values.
weights: numpy array, optional.
    Weights for weighted average.
axis: None or int, optional.
    Axis or axes along which to average a.
    The default, axis=None, will average over all of the elements of
    the input array. If axis is negative it counts from the last to first.

Returns
-------
rmse: numpy array or double.
    Return the RMSE along the specified axis.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-Percentage-Errors-"><span style="color:DarkOrange">2. Percentage Errors </span><a class="anchor-link" href="#2.-Percentage-Errors-"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Mean-Absolute-Percentage-Error">Mean Absolute Percentage Error<a class="anchor-link" href="#Mean-Absolute-Percentage-Error"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="mape" class="doc_header"><code>mape</code><a href="https://github.com/Nixtla/neuralforecast/tree/main/neuralforecast/losses/numpy.py#L161" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>mape</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>y_hat</code></strong>:<code>ndarray</code>, <strong><code>weights</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>, <strong><code>axis</code></strong>:<code>Optional</code>[<code>int</code>]=<em><code>None</code></em>)</p>
</blockquote>
<p>Calculates Mean Absolute Percentage Error (MAPE) between
y and y_hat. MAPE measures the relative prediction
accuracy of a forecasting method by calculating the percentual deviation
of the prediction and the observed value at a given time and
averages these devations over the length of the series.
The closer to zero an observed value is, the higher penalty MAPE loss
assigns to the corresponding error.</p>
$$ \mathrm{MAPE}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}_{\tau}) =
    \frac{1}{H} \sum^{t+H}_{\tau=t+1}
    \frac{|y_{\tau}-\hat{y}_{\tau}|}{|y_{\tau}|} $$
<pre><code>Parameters
----------
y: numpy array.
    Observed values.
y_hat: numpy array.
    Predicted values.
weights: numpy array, optional.
    Weights for weighted average.
axis: None or int, optional.
    Axis or axes along which to average a.
    The default, axis=None, will average over all of the elements of
    the input array. If axis is negative it counts from the last to first.

Returns
-------
mape: numpy array or double.
    Return the MAPE along the specified axis.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Symmetric-Mean-Absolute-Percentage-Error">Symmetric Mean Absolute Percentage Error<a class="anchor-link" href="#Symmetric-Mean-Absolute-Percentage-Error"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="smape" class="doc_header"><code>smape</code><a href="https://github.com/Nixtla/neuralforecast/tree/main/neuralforecast/losses/numpy.py#L207" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>smape</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>y_hat</code></strong>:<code>ndarray</code>, <strong><code>weights</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>, <strong><code>axis</code></strong>:<code>Optional</code>[<code>int</code>]=<em><code>None</code></em>)</p>
</blockquote>
<p>Calculates Symmetric Mean Absolute Percentage Error (SMAPE) between
y and y_hat. SMAPE measures the relative prediction
accuracy of a forecasting method by calculating the relative deviation
of the prediction and the observed value scaled by the sum of the
absolute values for the prediction and observed value at a
given time, then averages these devations over the length
of the series. This allows the SMAPE to have bounds between
0% and 200% which is desireble compared to normal MAPE that
may be undetermined when the target is zero.</p>
$$ \mathrm{SMAPE}_{2}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}_{\tau}) =
   \frac{1}{H} \sum^{t+H}_{\tau=t+1}
   \frac{|y_{\tau}-\hat{y}_{\tau}|}{|y_{\tau}|+|\hat{y}_{\tau}|} $$
<pre><code>Parameters
----------
y: numpy array.
    Observed values.
y_hat: numpy array.
    Predicted values.
weights: numpy array, optional.
    Weights for weighted average.
axis: None or int, optional.
    Axis or axes along which to average a.
    The default, axis=None, will average over all of the elements of
    the input array. If axis is negative it counts from the last to first.

Returns
-------
smape: numpy array or double.
    Return the SMAPE along the specified axis.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.-Scale-independent-Errors-"><span style="color:DarkOrange">3. Scale-independent Errors </span><a class="anchor-link" href="#3.-Scale-independent-Errors-"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Mean-Absolute-Scaled-Error">Mean Absolute Scaled Error<a class="anchor-link" href="#Mean-Absolute-Scaled-Error"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="mase" class="doc_header"><code>mase</code><a href="https://github.com/Nixtla/neuralforecast/tree/main/neuralforecast/losses/numpy.py#L259" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>mase</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>y_hat</code></strong>:<code>ndarray</code>, <strong><code>y_train</code></strong>:<code>ndarray</code>, <strong><code>seasonality</code></strong>:<code>int</code>, <strong><code>weights</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>, <strong><code>axis</code></strong>:<code>Optional</code>[<code>int</code>]=<em><code>None</code></em>)</p>
</blockquote>
<p>Calculates the Mean Absolute Scaled Error (MASE) between
y and y_hat. MASE measures the relative prediction
accuracy of a forecasting method by comparinng the mean absolute errors
of the prediction and the observed value against the mean
absolute errors of the seasonal naive model.
The MASE partially composed the Overall Weighted Average (OWA),
used in the M4 Competition.</p>
$$ \mathrm{MASE}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}_{\tau}, \mathbf{\hat{y}}^{season}_{\tau}) =
    \frac{1}{H} \sum^{t+H}_{\tau=t+1} \frac{|y_{\tau}-\hat{y}_{\tau}|}{\mathrm{MAE}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}^{season}_{\tau})} $$
<pre><code>Parameters
----------
y: numpy array.
    Observed values.
y_hat: numpy array.
    Predicted values.
y_train: numpy array.
    Actual insample Seasonal Naive predictions.
seasonality: int.
    Main frequency of the time series;
    Hourly 24,  Daily 7, Weekly 52,
    Monthly 12, Quarterly 4, Yearly 1.
weights: numpy array, optional.
    Weights for weighted average.
axis: None or int, optional.
    Axis or axes along which to average a.
    The default, axis=None, will average over all of the elements of
    the input array. If axis is negative it counts from the last to first.

Returns
-------
mase: numpy array or double.
    Return the mase along the specified axis.

References
----------
[1] https://robjhyndman.com/papers/mase.pdf</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Relative-Mean-Absolute-Error">Relative Mean Absolute Error<a class="anchor-link" href="#Relative-Mean-Absolute-Error"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="rmae" class="doc_header"><code>rmae</code><a href="https://github.com/Nixtla/neuralforecast/tree/main/neuralforecast/losses/numpy.py#L316" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>rmae</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>y_hat1</code></strong>:<code>ndarray</code>, <strong><code>y_hat2</code></strong>:<code>ndarray</code>, <strong><code>weights</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>, <strong><code>axis</code></strong>:<code>Optional</code>[<code>int</code>]=<em><code>None</code></em>)</p>
</blockquote>
<p>Calculates Relative Mean Absolute Error (RMAE) between
two sets of forecasts (from two different forecasting methods).
A number smaller than one implies that the forecast in the
numerator is better than the forecast in the denominator.</p>
$$ \mathrm{RMAE}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}_{\tau}, \mathbf{\hat{y}}^{base}_{\tau}) =
    \frac{1}{H} \sum^{t+H}_{\tau=t+1} \frac{|y_{\tau}-\hat{y}_{\tau}|}{\mathrm{MAE}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}^{base}_{\tau})} $$
<pre><code>Parameters
----------
y: numpy array.
    Observed values.
y_hat1: numpy array.
    Predicted values of first model.
y_hat2: numpy array.
    Predicted values of baseline model.
weights: numpy array, optional.
    Weights for weighted average.
axis: None or int, optional.
    Axis or axes along which to average a.
    The default, axis=None, will average over all of the elements of
    the input array. If axis is negative it counts from the last to first.

Returns
-------
rmae: numpy array or double.
    Return the RMAE along the specified axis.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="4.-Probabilistic-Errors-"><span style="color:DarkOrange">4. Probabilistic Errors </span><a class="anchor-link" href="#4.-Probabilistic-Errors-"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Quantile-Loss">Quantile Loss<a class="anchor-link" href="#Quantile-Loss"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="quantile_loss" class="doc_header"><code>quantile_loss</code><a href="https://github.com/Nixtla/neuralforecast/tree/main/neuralforecast/losses/numpy.py#L357" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>quantile_loss</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>y_hat</code></strong>:<code>ndarray</code>, <strong><code>q</code></strong>:<code>float</code>=<em><code>0.5</code></em>, <strong><code>weights</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>, <strong><code>axis</code></strong>:<code>Optional</code>[<code>int</code>]=<em><code>None</code></em>)</p>
</blockquote>
<p>Computes the quantile loss (QL) between y and y_hat.
QL measures the deviation of a quantile forecast.
By weighting the absolute deviation in a non symmetric way, the
loss pays more attention to under or over estimation.
A common value for q is 0.5 for the deviation from the median.</p>
$$ \mathrm{QL}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}^{(q)}_{\tau}) =
    \frac{1}{H} \sum^{t+H}_{\tau=t+1}
    \Big( (1-q)\,( \hat{y}^{(q)}_{\tau} - y_{\tau} )_{+}
    + q\,( y_{\tau} - \hat{y}^{(q)}_{\tau} )_{+} \Big) $$
<pre><code>Parameters
----------
y: numpy array.
    Observed values.
y_hat: numpy array.
    Predicted values.
q: float.
    Quantile for the predictions' comparison.
weights: numpy array, optional.
    Weights for weighted average.
axis: None or int, optional.
    Axis or axes along which to average a.
    The default, axis=None, will average over all of the elements of
    the input array. If axis is negative it counts from the last to first.

Returns
-------
quantile_loss: numpy array or double.
    Return the QL along the specified axis.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Multi-Quantile-Loss">Multi-Quantile Loss<a class="anchor-link" href="#Multi-Quantile-Loss"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="mqloss" class="doc_header"><code>mqloss</code><a href="https://github.com/Nixtla/neuralforecast/tree/main/neuralforecast/losses/numpy.py#L408" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>mqloss</code>(<strong><code>y</code></strong>:<code>ndarray</code>, <strong><code>y_hat</code></strong>:<code>ndarray</code>, <strong><code>quantiles</code></strong>:<code>ndarray</code>, <strong><code>weights</code></strong>:<code>Optional</code>[<code>ndarray</code>]=<em><code>None</code></em>, <strong><code>axis</code></strong>:<code>Optional</code>[<code>int</code>]=<em><code>None</code></em>)</p>
</blockquote>
<p>Calculates the Multi-Quantile loss (MQL) between y and y_hat.
MQL calculates the average multi-quantile Loss for
a given set of quantiles, based on the absolute
difference between predicted quantiles and observed values.</p>
$$ \mathrm{MQL}(\mathbf{y}_{\tau},
                [\mathbf{\hat{y}}^{(q_{1})}_{\tau}, ... ,\hat{y}^{(q_{n})}_{\tau}]) =
   \frac{1}{n} \sum_{q_{i}} \mathrm{QL}(\mathbf{y}_{\tau}, \mathbf{\hat{y}}^{(q_{i})}_{\tau}) $$<p>The limit behavior of MQL allows to measure the accuracy
of a full predictive distribution $\mathbf{\hat{F}}_{\tau}$ with
the continuous ranked probability score (CRPS). This can be achieved
through a numerical integration technique, that discretizes the quantiles
and treats the CRPS integral with a left Riemann approximation, averaging over
uniformly distanced quantiles.</p>
$$ \mathrm{CRPS}(y_{\tau}, \mathbf{\hat{F}}_{\tau}) =
    \int^{1}_{0} \mathrm{QL}(y_{\tau}, \hat{y}^{(q)}_{\tau}) dq $$
<pre><code>Parameters
----------
y: numpy array.
    Observed values.
y_hat: numpy array.
    Predicted values.
quantiles: numpy array.
    Quantiles to compare against.
weights: numpy array, optional.
    Weights for weighted average.
axis: None or int, optional.
    Axis or axes along which to average a.
    The default, axis=None, will average over all of the elements of
    the input array. If axis is negative it counts from the last to first.

Returns
-------
mqloss: numpy array or double.
    Return the MQL along the specified axis.

References
----------
[1] https://www.jstor.org/stable/2629907</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="-Examples-and-Validation-"><span style="color:DarkOrange"> Examples and Validation </span><a class="anchor-link" href="#-Examples-and-Validation-"> </a></h1>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">torch</span> <span class="k">as</span> <span class="nn">t</span> 
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">neuralforecast.losses.pytorch</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">MAELoss</span><span class="p">,</span> <span class="n">MSELoss</span><span class="p">,</span> <span class="n">RMSELoss</span><span class="p">,</span>  <span class="c1"># unscaled errors</span>
    <span class="n">MAPELoss</span><span class="p">,</span> <span class="n">SMAPELoss</span><span class="p">,</span>         <span class="c1"># percentage errors</span>
    <span class="n">MASELoss</span><span class="p">,</span> <span class="n">RMAELoss</span><span class="p">,</span>          <span class="c1"># scaled error</span>
    <span class="n">QuantileLoss</span><span class="p">,</span> <span class="n">MQLoss</span>         <span class="c1"># probabilistic errors</span>
<span class="p">)</span>
    
<span class="kn">from</span> <span class="nn">neuralforecast.losses.numpy</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">mae</span><span class="p">,</span> <span class="n">mse</span><span class="p">,</span> <span class="n">rmse</span><span class="p">,</span>              <span class="c1"># unscaled errors</span>
    <span class="n">mape</span><span class="p">,</span> <span class="n">smape</span><span class="p">,</span>                 <span class="c1"># percentage errors</span>
    <span class="n">mase</span><span class="p">,</span>                        <span class="c1"># scaled error</span>
    <span class="n">quantile_loss</span><span class="p">,</span> <span class="n">mqloss</span>        <span class="c1"># probabilistic errors</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">TestLoss</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>   
        <span class="bp">self</span><span class="o">.</span><span class="n">num_quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_num</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_num</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_hat2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_num</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_hat_quantile</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_quantiles</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_quantiles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_mae</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mae_numpy</span>   <span class="o">=</span> <span class="n">mae</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span>
        <span class="n">mae_pytorch</span> <span class="o">=</span> <span class="n">MAELoss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">mae_numpy</span><span class="p">,</span> <span class="n">mae_pytorch</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_mse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mse_numpy</span>   <span class="o">=</span> <span class="n">mse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span>
        <span class="n">mse_pytorch</span> <span class="o">=</span> <span class="n">MSELoss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">mse_numpy</span><span class="p">,</span> <span class="n">mse_pytorch</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_rmse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rmse_numpy</span>   <span class="o">=</span> <span class="n">rmse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span>
        <span class="n">rmse_pytorch</span> <span class="o">=</span> <span class="n">RMSELoss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">rmse_numpy</span><span class="p">,</span> <span class="n">rmse_pytorch</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_mape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mape_numpy</span>   <span class="o">=</span> <span class="n">mae</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span>
        <span class="n">mape_pytorch</span> <span class="o">=</span> <span class="n">MAELoss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">mape_numpy</span><span class="p">,</span> <span class="n">mape_pytorch</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_smape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">smape_numpy</span>   <span class="o">=</span> <span class="n">smape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span>
        <span class="n">smape_pytorch</span> <span class="o">=</span> <span class="n">SMAPELoss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">smape_numpy</span><span class="p">,</span> <span class="n">smape_pytorch</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    
    
    <span class="k">def</span> <span class="nf">test_mase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">y_insample</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_num</span><span class="p">)</span>
        <span class="n">seasonality</span> <span class="o">=</span> <span class="mi">24</span>
        <span class="c1"># Hourly 24, Daily 7, Weekly 52</span>
        <span class="c1"># Monthly 12, Quarterly 4, Yearly 1 </span>
        <span class="n">mase_numpy</span>   <span class="o">=</span> <span class="n">mase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">y_insample</span><span class="p">,</span> <span class="n">seasonality</span><span class="p">)</span>
        <span class="n">mase_pytorch</span> <span class="o">=</span> <span class="n">MASELoss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">y_insample</span><span class="p">,</span> <span class="n">seasonality</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">mase_numpy</span><span class="p">,</span> <span class="n">mase_pytorch</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">test_rmae</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rmae_numpy</span>   <span class="o">=</span> <span class="n">rmae</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat2</span><span class="p">)</span>
        <span class="n">rmae_pytorch</span> <span class="o">=</span> <span class="n">RMAELoss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat2</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">rmae_numpy</span><span class="p">,</span> <span class="n">rmae_pytorch</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    

    <span class="k">def</span> <span class="nf">test_quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">quantile_numpy</span> <span class="o">=</span> <span class="n">quantile_loss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_float</span><span class="p">)</span>
        <span class="n">quantile_pytorch</span> <span class="o">=</span> <span class="n">QuantileLoss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_float</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">quantile_numpy</span><span class="p">,</span> <span class="n">quantile_pytorch</span><span class="p">,</span> 
                               <span class="n">places</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">test_mqloss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="n">mql_np_w</span> <span class="o">=</span> <span class="n">mqloss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat_quantile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">mql_np_default_w</span> <span class="o">=</span> <span class="n">mqloss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat_quantile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span><span class="p">)</span>
        
        <span class="n">mql_py_w</span> <span class="o">=</span> <span class="n">MQLoss</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> 
              <span class="n">y_hat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y_hat_quantile</span><span class="p">,</span> 
              <span class="n">quantiles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span><span class="p">,</span>
              <span class="n">mask</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">mql_py_default_w</span> <span class="o">=</span> <span class="n">MQLoss</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> 
              <span class="n">y_hat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y_hat_quantile</span><span class="p">,</span> 
              <span class="n">quantiles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        
        <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mql_np_new_w</span> <span class="o">=</span> <span class="n">mqloss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat_quantile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">mql_py_new_w</span> <span class="o">=</span> <span class="n">MQLoss</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> 
                      <span class="n">y_hat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y_hat_quantile</span><span class="p">,</span> 
                      <span class="n">quantiles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span><span class="p">,</span>
                      <span class="n">mask</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">mql_np_w</span><span class="p">,</span>  <span class="n">mql_np_default_w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">mql_py_w</span><span class="p">,</span>  <span class="n">mql_py_default_w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">mql_np_new_w</span><span class="p">,</span>  <span class="n">mql_py_new_w</span><span class="p">)</span>
    

<span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">],</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">exit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

