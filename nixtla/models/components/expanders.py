# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/models_components__expanders.ipynb (unless otherwise specified).

__all__ = ['fExpander', 'yExpanderSP1', 'yExpanderSPN', 'sp1_to_spN_matrix', 'sp1_and_spN_names', 'list_ltsp']

# Cell
import numpy as np
import torch as t
import torch.nn as nn
import torch.nn.functional as F

# Cell
class fExpander(nn.Module):
    """
    Receives x input of dim [N,C,T+L]. Returns sliding
    windows of x [N,L,C,T] with L the lead time.
    lead: lead time, and size of each window
    step: stride for the sliding window
    Applies unfold transformation for each element in batch and
    channel against the T dimension to obtain sliding windows.
    """
    def __init__(self, n_time_in, n_time_out, step=1, dimension=-1):
        super(fExpander, self).__init__()
        self.n_time_in = n_time_in
        self.n_time_out = n_time_out
        self.step = step
        self.dimension = dimension
        self.padder = nn.ConstantPad1d(padding=(n_time_out, n_time_out), value=0)

    def forward(self, x):
        x = self.padder(x) # Pad lead_future to past and future [N,C,T+2*L]
        x = x.unfold(dimension=self.dimension,
                     size=self.n_time_out, step=self.step) # [N,C,T+2*L-1, L]
        # Eliminate auxiliary zero pad [N,C,T,L]
        x = x[:, :, self.n_time_out:self.n_time_out+self.n_time_in, :].contiguous()
        x = x.permute(0, 3, 1, 2).contiguous() # [N,L,C,T] reshape compatibility
        return x

# Cell
class yExpanderSP1(nn.Module):
    """
    Receives x input of dim [N, T]
    Returns sliding windows of x [N,L,T] with L the lead time
    size: lead time, and size of each window
    step: stride for the sliding window
    Applies unfold transformation for each element in batch and
    channel against the T dimension to obtain sliding windows.
    """
    def __init__(self, n_time_out, step=1, dimension=-1, value=0):
        super(yExpanderSP1, self).__init__()
        self.n_time_out = n_time_out
        self.step = step
        self.dimension = dimension
        self.padder = nn.ConstantPad1d(padding=(n_time_out, n_time_out), value=value)

    def forward(self, x):
        n, t = x.size()
        x = self.padder(x) # Pad lead_future to past and future [N,T+2*L]
        x = x.unfold(dimension=self.dimension,
                     size=self.n_time_out, step=self.step) # [N,T+2*L-1, L]
        # Eliminate auxiliary pad [N,T,L]
        x = x[:, self.n_time_out:t+self.n_time_out, :].contiguous()
        x = x.permute(0, 2, 1).contiguous() # [N,L,T] reshape compatibility
        return x

# Cell
class yExpanderSPN(nn.Module):
    """
    Receives x input of dim NxLxT
    Returns time aggregated x from matrix multiplication.
    ltsp_tr: lead to span transformation matrix
    """
    def __init__(self, ltsp_tr):
        super(yExpanderSPN, self).__init__()
        self.Amatrix = t.Tensor(ltsp_tr)

    def forward(self, x):
        x = t.einsum('blt,lh->bht', x, self.Amatrix)
        return x

# Cell
list_ltsp = [
         (0, 1),  (0, 2),  (0, 3),  (0, 4),  (0, 5),  (0, 6),  (0, 7),  (0, 8),  (0, 9),  (0, 10),  (0, 11),  (0, 12),  (0, 13),  (0, 14),  (0, 15),  (0, 16),  (0, 17),  (0, 18),  (0, 19),  (0, 20),  (0, 21),  (0, 22),  (0, 23),  (0, 24),  (0, 25),  (0, 26),  (0, 27),  (0, 28),  (0, 29),  (0, 30),  (0, 31),  (0, 32),  (0, 33),  (0, 34),  (0, 35),  (0, 36),  (0, 37),  (0, 38),  (0, 39),  (0, 40),  (0, 41),  (0, 42),  (0, 43),  (0, 44),  (0, 45),  (0, 46),  (0, 47),  (0, 48),
         (1, 1),  (1, 2),  (1, 3),  (1, 4),  (1, 5),  (1, 6),  (1, 7),
         (2, 1),  (2, 2),  (2, 3),  (2, 4),  (2, 5),  (2, 6),
         (3, 1),  (3, 2),  (3, 3),  (3, 4),  (3, 5),  (3, 6),  (3, 9),  (3, 12),  (3, 15),  (3, 18),  (3, 21),  (3, 24),  (3, 27),  (3, 30),  (3, 33),  (3, 36),  (3, 39),  (3, 42),  (3, 45),
         (4, 1),  (4, 2),  (4, 3),  (4, 4),
         (5, 1),  (5, 2),  (5, 3),
         (6, 1),  (6, 2),  (6, 3),  (6, 6),  (6, 9),  (6, 12),  (6, 15),  (6, 18),  (6, 21),  (6, 24),  (6, 27),  (6, 30),  (6, 33),  (6, 36),  (6, 39),  (6, 42),
         (7, 1),
         (8, 1),
         (9, 1),  (9, 3),  (9, 6),  (9, 9),  (9, 12),  (9, 15),  (9, 18),  (9, 21),  (9, 24),  (9, 27),  (9, 30),  (9, 33),  (9, 36),  (9, 39),
         (10, 1),
         (11, 1),
         (12, 1),  (12, 3),  (12, 6),  (12, 9),  (12, 12),  (12, 15),  (12, 18),  (12, 21),  (12, 24),  (12, 27),  (12, 30),  (12, 33),  (12, 36),
         (13, 1),
         (14, 1),
         (15, 1),  (15, 3),  (15, 6),  (15, 9),  (15, 12),  (15, 15),  (15, 18),  (15, 21),  (15, 24),  (15, 27),  (15, 30),  (15, 33),
         (16, 1),
         (17, 1),
         (18, 1),  (18, 3),  (18, 6),  (18, 9),  (18, 12),  (18, 15),  (18, 18),  (18, 21),  (18, 24),  (18, 27),  (18, 30),
         (19, 1),
         (20, 1),
         (21, 1),  (21, 3),  (21, 6),  (21, 9),  (21, 12),  (21, 15),  (21, 18),  (21, 21),  (21, 24),  (21, 27),
         (22, 1),
         (23, 1),
         (24, 1),  (24, 3),  (24, 6),  (24, 9),  (24, 12),  (24, 15),  (24, 18),  (24, 21),  (24, 24),
         (25, 1),
         (26, 1),
         (27, 1),  (27, 3),  (27, 6),  (27, 9),  (27, 12),  (27, 15),  (27, 18),  (27, 21),
         (28, 1),
         (29, 1),
         (30, 1),  (30, 3),  (30, 6),  (30, 9),  (30, 12),  (30, 15),  (30, 18),
         (31, 1),
         (32, 1),
         (33, 1),  (33, 3),  (33, 6),  (33, 9),  (33, 12),  (33, 15),
         (34, 1),
         (35, 1),
         (36, 1),  (36, 3),  (36, 6),  (36, 9),  (36, 12),
         (37, 1),
         (38, 1),
         (39, 1),  (39, 3),  (39, 6),  (39, 9),
         (40, 1),
         (41, 1),
         (42, 1),  (42, 3),  (42, 6),
         (43, 1),
         (44, 1),
         (45, 1),  (45, 3),
         (46, 1),
         (47, 1),
         (48, 1),
         (49, 1),
         (50, 1),
         (51, 1)]

def sp1_to_spN_matrix(Tpred,ltsps,normalize = False):
    # build the matrix transformer to convert SP1 forecasts to SP>1 (spN) forecasts, using the 235 hardcoded mesh points
    assert Tpred > 47
    ltsps_spN = [x for x in ltsps if x[1] != 1]
    ltsp_transformer = np.zeros((Tpred, len(ltsps_spN)))
    for iLtsp in range(len(ltsps_spN)):
        if normalize:
            normalizer = ltsps_spN[iLtsp][1]
        else:
            normalizer = 1.0
        ltsp_transformer[ltsps_spN[iLtsp][0]:ltsps_spN[iLtsp][0] + ltsps_spN[iLtsp][1], iLtsp] = 1.0 / normalizer
    return ltsp_transformer

def sp1_and_spN_names(ltsps):
    # get the names of the LTSPs in the mesh
    sp1_names = [str(x[0]) + '_' + str(x[1]) for x in ltsps if x[1] == 1]
    spN_names = [str(x[0]) + '_' + str(x[1]) for x in ltsps if x[1] != 1]
    return sp1_names + spN_names